{"version":3,"file":"static/js/523.704ccd83.chunk.js","mappings":"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","sources":["../node_modules/ol/proj/Units.js","../node_modules/ol/proj/Projection.js","../node_modules/ol/proj/epsg3857.js","../node_modules/ol/proj/epsg4326.js","../node_modules/ol/proj/projections.js","../node_modules/ol/proj/transforms.js","../node_modules/ol/proj.js","Shared/Components/UIELements/Map/Map.js","Places/Component/PlaceItem.js","Places/Component/PlaceList.js","Places/Pages/UserPlaces.js"],"sourcesContent":["/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  '9001': 'm',\n  '9002': 'ft',\n  '9003': 'us-ft',\n  '9101': 'radians',\n  '9102': 'degrees',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nexport const METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  'radians': 6370997 / (2 * Math.PI),\n  'degrees': (2 * Math.PI * 6370997) / 360,\n  'ft': 0.3048,\n  'm': 1,\n  'us-ft': 1200 / 3937,\n};\n","/**\n * @module ol/proj/Projection\n */\nimport {METERS_PER_UNIT} from './Units.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\nexport default Projection;\n","/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nexport const HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: 'm',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG3857Projection('EPSG:3857'),\n  new EPSG3857Projection('EPSG:102100'),\n  new EPSG3857Projection('EPSG:102113'),\n  new EPSG3857Projection('EPSG:900913'),\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n","/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: 'degrees',\n      extent: EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG4326Projection('CRS:84'),\n  new EPSG4326Projection('EPSG:4326', 'neu'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n","/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nlet cache = {};\n\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n  return (\n    cache[code] ||\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n    null\n  );\n}\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n","/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  let transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n","/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {getDistance} from './sphere.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output, dimension) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output, dimension) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string'\n    ? getProj(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326')\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return get(projection);\n  } else {\n    return /** @type {Projection} */ (projection);\n  }\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward)\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse)\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857'\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326'\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    const transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(\n  sourceProjection,\n  destinationProjection\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[sourceUnits]) / METERS_PER_UNIT[userUnits]\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326\n  );\n}\n\naddCommon();\n","import React, { useEffect, useRef, useState } from \"react\";\r\nimport Map from \"ol/Map\";\r\n\r\n// import ReactMapGl, { Marker } from \"react-map-gl\";\r\nimport \"./Map.css\";\r\nimport Tile from \"ol/Tile\";\r\nimport View from \"ol/View\";\r\nimport { fromLonLat } from \"ol/proj\";\r\nimport OSM from \"ol/source/OSM\";\r\n// import ReactMapGl from \"react-map-gl\";\r\n// function Map(props) {\r\n//   const [viewport, setViewport] = useState({\r\n//     latitude: 45.4211,\r\n//     longitude: -75.4211,\r\n//     width: \"50vw\",\r\n//     height: \"100vh\",\r\n//     zoom: 10,\r\n//   });\r\n//   return (\r\n//     <div>\r\n//       <ReactMapGl\r\n//         {...viewport}\r\n//         mapboxAccessToken={process.env.REACT_APP_MAPBOX_TOKEN}\r\n//       ></ReactMapGl>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// function Map(props) {\r\n//   const [viewport, setViewport] = useState({\r\n//     latitude: 45.4211,\r\n//     longitude: -75.4211,\r\n//     width: \"50vw\",\r\n//     height: \"100vh\",\r\n//     zoom: 10,\r\n//   });\r\n//   return (\r\n//     <div className=\"map\">\r\n//       <ReactMapGl\r\n//         {...viewport}\r\n//         mapboxAccessToken=\"\"\r\n//         onViewportChange={(viewport) => {\r\n//           setViewport(viewport);\r\n//         }}\r\n//         // style={{ width: 100, height: 100 }}\r\n//       >\r\n//         <Marker\r\n//           latitude={viewport.latitude}\r\n//           longitude={viewport.longitude}\r\n//         ></Marker>\r\n//       </ReactMapGl>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default Map;\r\n// function Map(props) {\r\n//   const mapRef = useRef();\r\n//   const { center, zoom } = props;\r\n//   useEffect(() => {\r\n//     const map = new window.google.maps.Map(mapRef.current, {\r\n//       center: center,\r\n//       zoom: zoom,\r\n//     });\r\n//     new window.google.maps.Marker({ position: center, map: map });\r\n//   }, [center, zoom]);\r\n//   return (\r\n//     <div\r\n//       ref={mapRef}\r\n//       className={`map ${props.className}`}\r\n//       style={props.style}\r\n//     ></div>\r\n//   );\r\n// }\r\n\r\n// export default Map;\r\nconst PlaceMap = (props) => {\r\n  // const mapRef = useRef();\r\n\r\n  // const { center, zoom } = props;\r\n\r\n  // useEffect(() => {\r\n  //   new Map({\r\n  //     layers: [\r\n  //       new Tile({\r\n  //         source: new OSM(),\r\n  //       }),\r\n  //     ],\r\n  //     target: mapRef.current.id,\r\n  //     view: new View({\r\n  //       center: fromLonLat([center.lng, center.lat]),\r\n  //       zoom: zoom,\r\n  //     }),\r\n  //   });\r\n  // }, [center, zoom]);\r\n\r\n  return (\r\n    <div\r\n      // ref={mapRef}\r\n      className={`map ${props.className}`}\r\n      style={props.style}\r\n      id=\"map\"\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default PlaceMap;\r\n","import React, { useContext, useState } from \"react\";\r\n\r\nimport Button from \"../../Shared/Components/FormElements/Button/Button\";\r\nimport Card from \"../../Shared/Components/UIELements/Card/Card\";\r\nimport ErrorModal from \"../../Shared/Components/UIELements/Error/ErrorModal\";\r\nimport LoadingSpinner from \"../../Shared/Components/UIELements/LoadingSpinner/LoadingSpinner\";\r\nimport PlaceMap from \"../../Shared/Components/UIELements/Map/Map\";\r\nimport Modal from \"../../Shared/Components/UIELements/Modal/Modal\";\r\nimport { AuthContext } from \"../../Shared/Context/Auth-Context\";\r\nimport { useHttpClient } from \"../../Shared/Hooks/http-hooks\";\r\nimport \"./PlaceItem.css\";\r\n\r\nfunction PlaceItem(props) {\r\n  const { isLoading, error, sendRequest, clearError } = useHttpClient();\r\n  const [showMap, setShowMap] = useState(false);\r\n  const [showConfirmModal, setShowConfirmModal] = useState(false);\r\n  const auth = useContext(AuthContext);\r\n\r\n  const openMapHandler = () => setShowMap(true);\r\n  const closeMapHandler = () => setShowMap(false);\r\n\r\n  const showDeleteWarningHandler = () => {\r\n    setShowConfirmModal(true);\r\n  };\r\n  const cancelDeleteWarningHandler = () => {\r\n    setShowConfirmModal(false);\r\n  };\r\n  const confirmDeleteWarningHandler = async () => {\r\n    setShowConfirmModal(false);\r\n    try {\r\n      await sendRequest(\r\n        `${process.env.REACT_APP_BACKEND_URL}/places/${props.id}`,\r\n        \"DELETE\",\r\n        null,\r\n        {\r\n          Authorization: \"Bearer \" + auth.token,\r\n        }\r\n      );\r\n      props.onDelete(props.id);\r\n    } catch (e) {}\r\n  };\r\n  return (\r\n    <>\r\n      <ErrorModal error={error} onClear={clearError} />\r\n\r\n      <Modal\r\n        show={showMap}\r\n        onCancel={closeMapHandler}\r\n        header={props.address}\r\n        contentClass=\"place-item__modal-content\"\r\n        footerClass=\"place-item__modal-actions\"\r\n        footer={<Button onClick={closeMapHandler}>CLOSE</Button>}\r\n      >\r\n        <div className=\"map-container\">\r\n          <PlaceMap center={props.coordinates} zoom={16} />\r\n        </div>\r\n      </Modal>\r\n      <Modal\r\n        show={showConfirmModal}\r\n        onCancel={cancelDeleteWarningHandler}\r\n        header=\"Are you sure?\"\r\n        footerClass=\"place-item__modal-actions\"\r\n        footer={\r\n          <>\r\n            <Button inverse onClick={cancelDeleteWarningHandler}>\r\n              CANCEL\r\n            </Button>\r\n            <Button danger onClick={confirmDeleteWarningHandler}>\r\n              DELETE\r\n            </Button>\r\n          </>\r\n        }\r\n      >\r\n        <p>\r\n          Do you want to proceed and delete this place? Please note that it\r\n          can't be undone thereafter.\r\n        </p>\r\n      </Modal>\r\n      <li className=\"place-item\">\r\n        <Card className=\"place-item__content\">\r\n          {isLoading && <LoadingSpinner asOverlay />}\r\n          <div className=\"place-item__image\">\r\n            <img\r\n              src={`${process.env.REACT_APP_ASSET_URL}/${props.image}`}\r\n              alt={props.title}\r\n            />\r\n          </div>\r\n          <div className=\"place-item__info\">\r\n            <h2>{props.title}</h2>\r\n            <h3>{props.address}</h3>\r\n            <p>{props.description}</p>\r\n          </div>\r\n          <div className=\"place-item__actions\">\r\n            <Button inverse onClick={openMapHandler}>\r\n              VIEW ON MAP\r\n            </Button>\r\n            {auth.userId === props.creatorId && (\r\n              <Button to={`/places/${props.id}`}>EDIT</Button>\r\n            )}\r\n\r\n            {auth.userId === props.creatorId && (\r\n              <Button danger onClick={showDeleteWarningHandler}>\r\n                DELETE\r\n              </Button>\r\n            )}\r\n          </div>\r\n        </Card>\r\n      </li>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default PlaceItem;\r\n","import React from \"react\";\r\nimport Button from \"../../Shared/Components/FormElements/Button/Button\";\r\nimport Card from \"../../Shared/Components/UIELements/Card/Card\";\r\nimport PlaceItem from \"./PlaceItem\";\r\n\r\nimport \"./PlaceList.css\";\r\n\r\nfunction PlaceList(props) {\r\n  const places = props.items.map((place) => (\r\n    <PlaceItem\r\n      id={place.id}\r\n      key={place.id}\r\n      image={place.image}\r\n      title={place.title}\r\n      address={place.address}\r\n      description={place.description}\r\n      creatorId={place.creator}\r\n      coordinates={place.location}\r\n      onDelete={props.onDeletePlace}\r\n    />\r\n  ));\r\n  return (\r\n    <>\r\n      {props.items.length === 0 ? (\r\n        <div className=\"place-list center\">\r\n          <Card>\r\n            <h2>No Places Found. Maybe create one</h2>\r\n            <Button to=\"/places/new\">Share Place</Button>\r\n          </Card>\r\n        </div>\r\n      ) : (\r\n        <ul className=\"place-list\">{places}</ul>\r\n      )}\r\n      ;\r\n    </>\r\n  );\r\n}\r\n\r\nexport default PlaceList;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport { useParams } from \"react-router-dom\";\r\nimport Card from \"../../Shared/Components/UIELements/Card/Card\";\r\nimport ErrorModal from \"../../Shared/Components/UIELements/Error/ErrorModal\";\r\nimport LoadingSpinner from \"../../Shared/Components/UIELements/LoadingSpinner/LoadingSpinner\";\r\nimport { useHttpClient } from \"../../Shared/Hooks/http-hooks\";\r\nimport PlaceList from \"../Component/PlaceList\";\r\n\r\nfunction UserPlaces(props) {\r\n  const [loadedPlaces, setLoadedPlaces] = useState();\r\n  const { isLoading, error, sendRequest, clearError } = useHttpClient();\r\n  const { userId } = useParams();\r\n  useEffect(() => {\r\n    const fetchUsers = async () => {\r\n      try {\r\n        const responseData = await sendRequest(\r\n          `${process.env.REACT_APP_BACKEND_URL}/places/users/${userId}`\r\n        );\r\n        setLoadedPlaces(responseData.places);\r\n      } catch (e) {}\r\n    };\r\n    fetchUsers();\r\n  }, [sendRequest, userId]);\r\n  const placeDeletedHandler = (deletedPlace) => {\r\n    setLoadedPlaces((prevPlaces) =>\r\n      prevPlaces.filter((p) => p.id !== deletedPlace)\r\n    );\r\n  };\r\n\r\n  return (\r\n    <>\r\n      {loadedPlaces && <ErrorModal error={error} onClear={clearError} />}\r\n      {isLoading && (\r\n        <div className=\"center\">\r\n          <LoadingSpinner />\r\n        </div>\r\n      )}\r\n      {!isLoading && !loadedPlaces && (\r\n        <div className=\"center\">\r\n          <Card>\r\n            <h2>You do not have any create places!</h2>\r\n          </Card>\r\n        </div>\r\n      )}\r\n\r\n      {!isLoading && loadedPlaces && (\r\n        <PlaceList items={loadedPlaces} onDeletePlace={placeDeletedHandler} />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default UserPlaces;\r\n"],"names":["METERS_PER_UNIT","Math","PI","Projection","options","this","code_","code","units_","units","extent_","undefined","extent","worldExtent_","worldExtent","axisOrientation_","axisOrientation","global_","global","canWrapX_","getPointResolutionFunc_","getPointResolution","defaultTileGrid_","metersPerUnit_","metersPerUnit","tileGrid","func","RADIUS","HALF_SIZE","EXTENT","WORLD_EXTENT","MAX_SAFE_Y","log","tan","EPSG3857Projection","resolution","point","cosh","PROJECTIONS","fromEPSG4326","input","output","dimension","length","slice","Array","i","y","toEPSG4326","atan","exp","EPSG4326Projection","cache","transforms","add","source","destination","transformFn","sourceCode","getCode","destinationCode","cloneTransform","ii","addProjection","projection","addProj","addTransformFunc","addEquivalentProjections","projections","forEach","addProjections","projections2","forwardTransform","inverseTransform","EPSG3857_PROJECTIONS","EPSG4326_PROJECTIONS","projection1","projection2","addCommon","props","className","style","id","useHttpClient","isLoading","error","sendRequest","clearError","useState","showMap","setShowMap","showConfirmModal","setShowConfirmModal","auth","useContext","AuthContext","closeMapHandler","cancelDeleteWarningHandler","confirmDeleteWarningHandler","process","Authorization","token","onDelete","ErrorModal","onClear","Modal","show","onCancel","header","address","contentClass","footerClass","footer","Button","onClick","center","coordinates","zoom","inverse","danger","Card","LoadingSpinner","asOverlay","src","image","alt","title","description","userId","creatorId","to","places","items","map","place","creator","location","onDeletePlace","loadedPlaces","setLoadedPlaces","useParams","useEffect","fetchUsers","responseData","deletedPlace","prevPlaces","filter","p"],"sourceRoot":""}